# 初识Docker

## What is Docker?

Docker 是世界领先的软件**容器**平台。Docker 的基础是 Linux 容器（LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。      -以上内容均来自官方文档摘录。

​                          

## What is Container?

容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。      -以上内容均来自官方文档摘录。



## 目前的虚拟化技术

虚拟机 (VM) 是一个**物理硬件层**抽象，用于将一台服务器变成多台服务器。管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源。

虚拟化技术.png



- 优点
  - 资源池分配精确---一个物理机的资源可以按需分配到不同的虚拟机里
  - 扩展性强----可以随时随地增加物理机或者虚拟机
  - 可云化---我们使用的阿里云，AWS 等就是基于虚拟化技术。
- 缺点
  - 资源消耗大--由于每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且 VM 启动也十分缓慢。
  - 开发以及运维繁琐---开发人员需要在每个虚拟机上安装对应的开发软件，对于运维而言，需要程序的部署以及监控（包括系统安装，基础环境安装等）以及硬件环境的差异。



## 之后的容器技术

容器是一个**应用层**抽象，用于将**代码和依赖资源**打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。

容器技术.png



由于容器技术将代码和依赖资源打包在一起，因此解决了运维和开发之间的矛盾。



## 虚拟化技术 VS 容器技术

|            特性            |  虚拟化  |    容器    |
| :------------------------: | :------: | :--------: |
|            隔离            |  物理层  |   应用层   |
|            启动            |  分钟级  |    秒级    |
|            性能            | 弱于原生 | 接近于原生 |
| 系统支持量（相同硬件环境） |  10倍级  |   百倍级   |





## Docker的架构以及底层技术

### 大体描述

首先Docker是一个Platform,提供了开发，打包，运行app的平台。

dockerengine.png

由上图可以看出，docker把底层基础架构和上层的应用隔离开来。



### Docker Engine

dockerE.png

我们通过图中可以看到 Dokcer Engine 大体分三个部分

- Server中有一个后台进程 （dockerd）
- REST API 实现了client和server间的交互协议
- CLI 实现容器、镜像、网络以及存储的管理

在稍后我们介绍如何在centos上安装docker后，可以使用命令去查看这三个部分的进程。



### Docker架构

architecture.jpg

我们可以看到在这个详细的架构图中我们看出架构组成

- Docker Client:向Docker Host 发送各种命令。
  - Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。
  - pull（拉取镜像）：从仓库间拉取镜像到Docker Host。
  - Run （运行镜像）：运行的镜像就是一个容器，容器就是运行程序的地方。
- Docker Host: 安装Docker的机器，已经启动了 docker deamon 后台进程。 包含了容器(container)以及镜像(image)
- Registry:存储镜像的公共服务器类似于github,在这里叫  [dockerHub](https://hub.docker.com/)



#### 镜像（Image） ----一个特殊的文件系统

image.png

Docker镜像是一个特殊的文件系统如图中的 Base Image，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。

我们可以Base Image基础之上，创建新的image,如图在centos的Base Image 之上可以创建一个mysql (image#2)，然后可以在image#2上再继续创建image。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。不同的image可以共享base image的资源。

image只是可读的。



#### 容器（Container）——镜像运行时的实体

container.png

首先container是基于image创建的，并且是可以读写的一层（image只能读），也就是说先有image才可以有container。镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。



#### 仓库（Repository）——集中存放镜像文件的地方

镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。







### Docker底层技术

- 隔离技术：

  - namespace

    | namespace |          隔离内容          |
    | :-------: | :------------------------: |
    |    UTS    |        主机名和域名        |
    |    IPC    | 信号量，消息队列，共享内存 |
    |    PID    |           进程号           |
    |  Network  |       网络设备，端口       |
    |   Mount   |          文件系统          |
    |   User    |        用户和用户组        |

  - Control Groups

    - 提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO等等）的机制

  - 简称UnionFS，他是一种为Linux 、FreeBSD 和NetBSD 操作系统设计的，把其他文件系统联合到一个联合挂载点的文件系统服务。它用到了一个重要的资源管理技术,叫写时复制。写时复制（copy-on-write），也叫隐式共享，是一种对可修改资源实现高效复制的资源管理技术。对于一个重复资源，若不修改，则无需立刻创建一个新的资源，该资源可以被共享使用。当发生修改的时候，才会创建新资源。这会大大减少对于未修改资源复制的消耗。Docker正式基于此去创建images和containers。



由于都是linux相关的技术，我也是百度个大概知道大体每个技术是干什么的。如果想深入了解docker底层，还是要钻研一下linux。



## 总结

本文主要是把docker的基本概念介绍了一下，方便之后的安装，创建镜像，运行容器等操作。详细的内容还是建议阅读官方文档。